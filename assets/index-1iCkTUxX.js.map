{"version":3,"mappings":"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","names":["baseAccount","parameters","walletProvider","accountsChanged","chainChanged","disconnect","createConnector","config","chainId","withCapabilities","provider","accounts","x","getAddress","currentChainId","chain","error","UserRejectedRequestError","address","preference","_a","createBaseAccountSDK","__vitePreload","addEthereumChainParameter","SwitchChainError","ChainNotConfiguredError","numberToHex","blockExplorerUrls","_b","rpcUrls","_c","_d","addEthereumChain","_error","safe","shimDisconnect","provider_","ProviderNotFoundError","SDK","sdk","withTimeout","SafeAppProvider","Provider","n"],"ignoreList":[0,1],"sources":["../../node_modules/@wagmi/connectors/dist/esm/baseAccount.js","../../node_modules/@wagmi/connectors/dist/esm/safe.js"],"sourcesContent":["import { ChainNotConfiguredError, createConnector, } from '@wagmi/core';\nimport { getAddress, numberToHex, SwitchChainError, UserRejectedRequestError, } from 'viem';\nexport function baseAccount(parameters = {}) {\n    let walletProvider;\n    let accountsChanged;\n    let chainChanged;\n    let disconnect;\n    return createConnector((config) => ({\n        id: 'baseAccount',\n        name: 'Base Account',\n        rdns: 'app.base.account',\n        type: 'baseAccount',\n        async connect({ chainId, withCapabilities } = {}) {\n            try {\n                const provider = await this.getProvider();\n                const accounts = (await provider.request({\n                    method: 'eth_requestAccounts',\n                    params: [],\n                })).map((x) => getAddress(x));\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n                // Switch to chain if provided\n                let currentChainId = await this.getChainId();\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === UserRejectedRequestError.code)\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                return {\n                    // TODO(v3): Make `withCapabilities: true` default behavior\n                    accounts: (withCapabilities\n                        ? accounts.map((address) => ({ address, capabilities: {} }))\n                        : accounts),\n                    chainId: currentChainId,\n                };\n            }\n            catch (error) {\n                if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))\n                    throw new UserRejectedRequestError(error);\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            provider.disconnect();\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            return (await provider.request({\n                method: 'eth_accounts',\n            })).map((x) => getAddress(x));\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            const chainId = (await provider.request({\n                method: 'eth_chainId',\n            }));\n            return Number(chainId);\n        },\n        async getProvider() {\n            if (!walletProvider) {\n                const preference = (() => {\n                    if (typeof parameters.preference === 'string')\n                        return { options: parameters.preference };\n                    return {\n                        ...parameters.preference,\n                        options: parameters.preference?.options ?? 'all',\n                    };\n                })();\n                const { createBaseAccountSDK } = await import('@base-org/account');\n                const sdk = createBaseAccountSDK({\n                    ...parameters,\n                    appChainIds: config.chains.map((x) => x.id),\n                    preference,\n                });\n                walletProvider = sdk.getProvider();\n            }\n            return walletProvider;\n        },\n        async isAuthorized() {\n            try {\n                const accounts = await this.getAccounts();\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ addEthereumChainParameter, chainId }) {\n            const chain = config.chains.find((chain) => chain.id === chainId);\n            if (!chain)\n                throw new SwitchChainError(new ChainNotConfiguredError());\n            const provider = await this.getProvider();\n            try {\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: numberToHex(chain.id) }],\n                });\n                return chain;\n            }\n            catch (error) {\n                // Indicates chain is not added to provider\n                if (error.code === 4902) {\n                    try {\n                        let blockExplorerUrls;\n                        if (addEthereumChainParameter?.blockExplorerUrls)\n                            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n                        else\n                            blockExplorerUrls = chain.blockExplorers?.default.url\n                                ? [chain.blockExplorers?.default.url]\n                                : [];\n                        let rpcUrls;\n                        if (addEthereumChainParameter?.rpcUrls?.length)\n                            rpcUrls = addEthereumChainParameter.rpcUrls;\n                        else\n                            rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n                        const addEthereumChain = {\n                            blockExplorerUrls,\n                            chainId: numberToHex(chainId),\n                            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                            iconUrls: addEthereumChainParameter?.iconUrls,\n                            nativeCurrency: addEthereumChainParameter?.nativeCurrency ??\n                                chain.nativeCurrency,\n                            rpcUrls,\n                        };\n                        await provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [addEthereumChain],\n                        });\n                        return chain;\n                    }\n                    catch (error) {\n                        throw new UserRejectedRequestError(error);\n                    }\n                }\n                throw new SwitchChainError(error);\n            }\n        },\n        onAccountsChanged(accounts) {\n            if (accounts.length === 0)\n                this.onDisconnect();\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => getAddress(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onDisconnect(_error) {\n            config.emitter.emit('disconnect');\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n        },\n    }));\n}\n//# sourceMappingURL=baseAccount.js.map","import { createConnector, ProviderNotFoundError, } from '@wagmi/core';\nimport { getAddress, withTimeout } from 'viem';\nsafe.type = 'safe';\nexport function safe(parameters = {}) {\n    const { shimDisconnect = false } = parameters;\n    let provider_;\n    let disconnect;\n    return createConnector((config) => ({\n        id: 'safe',\n        name: 'Safe',\n        type: safe.type,\n        async connect({ withCapabilities } = {}) {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            const accounts = await this.getAccounts();\n            const chainId = await this.getChainId();\n            if (!disconnect) {\n                disconnect = this.onDisconnect.bind(this);\n                provider.on('disconnect', disconnect);\n            }\n            // Remove disconnected shim if it exists\n            if (shimDisconnect)\n                await config.storage?.removeItem('safe.disconnected');\n            return {\n                // TODO(v3): Make `withCapabilities: true` default behavior\n                accounts: (withCapabilities\n                    ? accounts.map((address) => ({ address, capabilities: {} }))\n                    : accounts),\n                chainId,\n            };\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            // Add shim signalling connector is disconnected\n            if (shimDisconnect)\n                await config.storage?.setItem('safe.disconnected', true);\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            return (await provider.request({ method: 'eth_accounts' })).map(getAddress);\n        },\n        async getProvider() {\n            // Only allowed in iframe context\n            const isIframe = typeof window !== 'undefined' && window?.parent !== window;\n            if (!isIframe)\n                return;\n            if (!provider_) {\n                const { default: SDK } = await import('@safe-global/safe-apps-sdk');\n                const sdk = new SDK(parameters);\n                // `getInfo` hangs when not used in Safe App iFrame\n                // https://github.com/safe-global/safe-apps-sdk/issues/263#issuecomment-1029835840\n                const safe = await withTimeout(() => sdk.safe.getInfo(), {\n                    timeout: parameters.unstable_getInfoTimeout ?? 10,\n                });\n                if (!safe)\n                    throw new Error('Could not load Safe information');\n                // Unwrapping import for Vite compatibility.\n                // See: https://github.com/vitejs/vite/issues/9703\n                const SafeAppProvider = await (async () => {\n                    const Provider = await import('@safe-global/safe-apps-provider');\n                    if (typeof Provider.SafeAppProvider !== 'function' &&\n                        typeof Provider.default.SafeAppProvider === 'function')\n                        return Provider.default.SafeAppProvider;\n                    return Provider.SafeAppProvider;\n                })();\n                provider_ = new SafeAppProvider(safe, sdk);\n            }\n            return provider_;\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            return Number(provider.chainId);\n        },\n        async isAuthorized() {\n            try {\n                const isDisconnected = shimDisconnect &&\n                    // If shim exists in storage, connector is disconnected\n                    (await config.storage?.getItem('safe.disconnected'));\n                if (isDisconnected)\n                    return false;\n                const accounts = await this.getAccounts();\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        onAccountsChanged() {\n            // Not relevant for Safe because changing account requires app reload.\n        },\n        onChainChanged() {\n            // Not relevant for Safe because Safe smart contract wallets only exist on single chain.\n        },\n        onDisconnect() {\n            config.emitter.emit('disconnect');\n        },\n    }));\n}\n//# sourceMappingURL=safe.js.map"],"file":"assets/index-1iCkTUxX.js"}